<refentry id="gsf-Input-from-unstructured-files">
<refmeta>
<refentrytitle role="top_of_page" id="gsf-Input-from-unstructured-files.top_of_page">Input from unstructured files</refentrytitle>
<manvolnum>3</manvolnum>
<refmiscinfo>GSF Library</refmiscinfo>
</refmeta>

<refnamediv>
<refname>Input from unstructured files</refname>
<refpurpose></refpurpose>
<!--[<xref linkend="desc" endterm="desc.title"/>]-->
</refnamediv>

<refsynopsisdiv id="gsf-Input-from-unstructured-files.synopsis" role="synopsis">
<title role="synopsis.title">Synopsis</title>
<anchor id="GsfInput"/><anchor id="GsfInputProxy"/>
<synopsis>
                    <link linkend="GsfInput-struct">GsfInput</link>;
<link linkend="guint8">guint8</link>const *       <link linkend="gsf-input-read">gsf_input_read</link>                      (<link linkend="GsfInput">GsfInput</link> *input,
                                                         <link linkend="size-t">size_t</link> num_bytes,
                                                         <link linkend="guint8">guint8</link> *optional_buffer);
<link linkend="gsf-off-t">gsf_off_t</link>           <link linkend="gsf-input-tell">gsf_input_tell</link>                      (<link linkend="GsfInput">GsfInput</link> *input);
<link linkend="gboolean">gboolean</link>            <link linkend="gsf-input-seek">gsf_input_seek</link>                      (<link linkend="GsfInput">GsfInput</link> *input,
                                                         <link linkend="gsf-off-t">gsf_off_t</link> offset,
                                                         <link linkend="GSeekType">GSeekType</link> whence);
<link linkend="GsfInfile">GsfInfile</link>*          <link linkend="gsf-input-container">gsf_input_container</link>                 (<link linkend="GsfInput">GsfInput</link> *input);
<link linkend="GsfInput">GsfInput</link>*           <link linkend="gsf-input-dup">gsf_input_dup</link>                       (<link linkend="GsfInput">GsfInput</link> *input,
                                                         <link linkend="GError">GError</link> **err);
<link linkend="gsf-off-t">gsf_off_t</link>           <link linkend="gsf-input-size">gsf_input_size</link>                      (<link linkend="GsfInput">GsfInput</link> *input);
<link linkend="gboolean">gboolean</link>            <link linkend="gsf-input-eof">gsf_input_eof</link>                       (<link linkend="GsfInput">GsfInput</link> *input);
<link linkend="gsf-off-t">gsf_off_t</link>           <link linkend="gsf-input-remaining">gsf_input_remaining</link>                 (<link linkend="GsfInput">GsfInput</link> *input);
<link linkend="GQuark">GQuark</link>              <link linkend="gsf-input-error-id">gsf_input_error_id</link>                  (void);
<link linkend="GsfInput">GsfInput</link>*           <link linkend="gsf-input-sibling">gsf_input_sibling</link>                   (<link linkend="GsfInput">GsfInput</link> const *input,
                                                         <link linkend="char">char</link> const *name,
                                                         <link linkend="GError">GError</link> **err);
<link linkend="GQuark">GQuark</link>              <link linkend="gsf-input-error">gsf_input_error</link>                     (void);
<link linkend="char">char</link>const   *       <link linkend="gsf-input-name">gsf_input_name</link>                      (<link linkend="GsfInput">GsfInput</link> *input);
<link linkend="gboolean">gboolean</link>            <link linkend="gsf-input-set-name-from-filename">gsf_input_set_name_from_filename</link>    (<link linkend="GsfInput">GsfInput</link> *input,
                                                         <link linkend="char">char</link> const *filename);
                    <link linkend="GsfInputProxy-struct">GsfInputProxy</link>;
<link linkend="GsfInput">GsfInput</link>*           <link linkend="gsf-input-proxy-new">gsf_input_proxy_new</link>                 (<link linkend="GsfInput">GsfInput</link> *source);
<link linkend="GsfInput">GsfInput</link>*           <link linkend="gsf-input-proxy-new-section">gsf_input_proxy_new_section</link>         (<link linkend="GsfInput">GsfInput</link> *source,
                                                         <link linkend="gsf-off-t">gsf_off_t</link> offset,
                                                         <link linkend="gsf-off-t">gsf_off_t</link> size);

<link linkend="gboolean">gboolean</link>            <link linkend="gsf-input-copy">gsf_input_copy</link>                      (<link linkend="GsfInput">GsfInput</link> *input,
                                                         <link linkend="GsfOutput">GsfOutput</link> *output);
<link linkend="GsfInput">GsfInput</link>*           <link linkend="gsf-input-uncompress">gsf_input_uncompress</link>                (<link linkend="GsfInput">GsfInput</link> *src);
</synopsis>
</refsynopsisdiv>

<refsect1 id="gsf-Input-from-unstructured-files.object-hierarchy" role="object_hierarchy">
<title role="object_hierarchy.title">Object Hierarchy</title>
<synopsis>
  <link linkend="GObject">GObject</link>
   +----GsfInput
         +----<link linkend="GsfInfile">GsfInfile</link>
         +----<link linkend="GsfInputGZip">GsfInputGZip</link>
         +----<link linkend="GsfInputMemory">GsfInputMemory</link>
         +----<link linkend="GsfInputProxy">GsfInputProxy</link>
         +----<link linkend="GsfInputStdio">GsfInputStdio</link>
         +----<link linkend="GsfInputTextline">GsfInputTextline</link>
</synopsis>
<synopsis>
  <link linkend="GObject">GObject</link>
   +----<link linkend="GsfInput">GsfInput</link>
         +----GsfInputProxy
</synopsis>

</refsect1>





<refsect1 id="gsf-Input-from-unstructured-files.properties" role="properties">
<title role="properties.title">Properties</title>
<synopsis>
  &quot;<link linkend="GsfInput--eof">eof</link>&quot;                      <link linkend="gboolean">gboolean</link>              : Read
  &quot;<link linkend="GsfInput--name">name</link>&quot;                     <link linkend="gchar">gchar</link>*                : Read
  &quot;<link linkend="GsfInput--position">position</link>&quot;                 <link linkend="gint64">gint64</link>                : Read
  &quot;<link linkend="GsfInput--remaining">remaining</link>&quot;                <link linkend="gint64">gint64</link>                : Read
  &quot;<link linkend="GsfInput--size">size</link>&quot;                     <link linkend="gint64">gint64</link>                : Read
</synopsis>
</refsect1>



<refsect1 id="gsf-Input-from-unstructured-files.description" role="desc">
<title role="desc.title">Description</title>
<para>

</para>
</refsect1>

<refsect1 id="gsf-Input-from-unstructured-files.details" role="details">
<title role="details.title">Details</title>
<refsect2 id="GsfInput-struct" role="struct">
<title>GsfInput</title>
<indexterm zone="GsfInput-struct"><primary>GsfInput</primary></indexterm><programlisting>typedef struct _GsfInput GsfInput;</programlisting>
<para>
Class representing an input stream.</para>
<para>

</para></refsect2>
<refsect2 id="gsf-input-read" role="function">
<title>gsf_input_read ()</title>
<indexterm zone="gsf-input-read"><primary>gsf_input_read</primary></indexterm><programlisting><link linkend="guint8">guint8</link>const *       gsf_input_read                      (<link linkend="GsfInput">GsfInput</link> *input,
                                                         <link linkend="size-t">size_t</link> num_bytes,
                                                         <link linkend="guint8">guint8</link> *optional_buffer);</programlisting>
<para>
Read at least <parameter>num_bytes</parameter>.  Does not change the current position if there
is an error.  Will only read if the entire amount can be read.  Invalidates
the buffer associated with previous calls to gsf_input_read.</para>
<para>

</para><variablelist role="params">
<varlistentry><term><parameter>input</parameter>&nbsp;:</term>
<listitem><simpara> the input stream
</simpara></listitem></varlistentry>
<varlistentry><term><parameter>num_bytes</parameter>&nbsp;:</term>
<listitem><simpara> number of bytes to read
</simpara></listitem></varlistentry>
<varlistentry><term><parameter>optional_buffer</parameter>&nbsp;:</term>
<listitem><simpara> <link linkend="NULL:CAPS"><literal>NULL</literal></link>, or pointer to destination memory area
</simpara></listitem></varlistentry>
<varlistentry><term><emphasis>Returns</emphasis>&nbsp;:</term><listitem><simpara> pointer to the buffer or <link linkend="NULL:CAPS"><literal>NULL</literal></link> if there is an error or 0 bytes are
	requested.
</simpara></listitem></varlistentry>
</variablelist></refsect2>
<refsect2 id="gsf-input-tell" role="function">
<title>gsf_input_tell ()</title>
<indexterm zone="gsf-input-tell"><primary>gsf_input_tell</primary></indexterm><programlisting><link linkend="gsf-off-t">gsf_off_t</link>           gsf_input_tell                      (<link linkend="GsfInput">GsfInput</link> *input);</programlisting>
<para>
</para>
<para>

</para><variablelist role="params">
<varlistentry><term><parameter>input</parameter>&nbsp;:</term>
<listitem><simpara> the input stream
</simpara></listitem></varlistentry>
<varlistentry><term><emphasis>Returns</emphasis>&nbsp;:</term><listitem><simpara> the current offset in the file.
</simpara></listitem></varlistentry>
</variablelist></refsect2>
<refsect2 id="gsf-input-seek" role="function">
<title>gsf_input_seek ()</title>
<indexterm zone="gsf-input-seek"><primary>gsf_input_seek</primary></indexterm><programlisting><link linkend="gboolean">gboolean</link>            gsf_input_seek                      (<link linkend="GsfInput">GsfInput</link> *input,
                                                         <link linkend="gsf-off-t">gsf_off_t</link> offset,
                                                         <link linkend="GSeekType">GSeekType</link> whence);</programlisting>
<para>
Move the current location in the input stream.</para>
<para>

</para><variablelist role="params">
<varlistentry><term><parameter>input</parameter>&nbsp;:</term>
<listitem><simpara> the input stream
</simpara></listitem></varlistentry>
<varlistentry><term><parameter>offset</parameter>&nbsp;:</term>
<listitem><simpara> target offset
</simpara></listitem></varlistentry>
<varlistentry><term><parameter>whence</parameter>&nbsp;:</term>
<listitem><simpara> determines whether the offset is relative to the beginning or
         the end of the stream, or to the current location.
</simpara></listitem></varlistentry>
<varlistentry><term><emphasis>Returns</emphasis>&nbsp;:</term><listitem><simpara> TRUE on error.
</simpara></listitem></varlistentry>
</variablelist></refsect2>
<refsect2 id="gsf-input-container" role="function">
<title>gsf_input_container ()</title>
<indexterm zone="gsf-input-container"><primary>gsf_input_container</primary></indexterm><programlisting><link linkend="GsfInfile">GsfInfile</link>*          gsf_input_container                 (<link linkend="GsfInput">GsfInput</link> *input);</programlisting>
<para>
</para>
<para>

</para><variablelist role="params">
<varlistentry><term><parameter>input</parameter>&nbsp;:</term>
<listitem><simpara> the input stream
</simpara></listitem></varlistentry>
<varlistentry><term><emphasis>Returns</emphasis>&nbsp;:</term><listitem><simpara> but does not add a reference to <parameter>input</parameter>'s container.
	Potentially <link linkend="NULL:CAPS"><literal>NULL</literal></link>
</simpara></listitem></varlistentry>
</variablelist></refsect2>
<refsect2 id="gsf-input-dup" role="function">
<title>gsf_input_dup ()</title>
<indexterm zone="gsf-input-dup"><primary>gsf_input_dup</primary></indexterm><programlisting><link linkend="GsfInput">GsfInput</link>*           gsf_input_dup                       (<link linkend="GsfInput">GsfInput</link> *input,
                                                         <link linkend="GError">GError</link> **err);</programlisting>
<para>
Duplicates input <parameter>src</parameter> leaving the new one at the same offset.</para>
<para>

</para><variablelist role="params">
<varlistentry><term><parameter>input</parameter>&nbsp;:</term>
<listitem><simpara> The input to duplicate
</simpara></listitem></varlistentry>
<varlistentry><term><parameter>err</parameter>&nbsp;:</term>
<listitem><simpara> optionally <link linkend="NULL:CAPS"><literal>NULL</literal></link>
</simpara></listitem></varlistentry>
<varlistentry><term><emphasis>Returns</emphasis>&nbsp;:</term><listitem><simpara> the duplicate, or <link linkend="NULL:CAPS"><literal>NULL</literal></link> on error
</simpara></listitem></varlistentry>
</variablelist></refsect2>
<refsect2 id="gsf-input-size" role="function">
<title>gsf_input_size ()</title>
<indexterm zone="gsf-input-size"><primary>gsf_input_size</primary></indexterm><programlisting><link linkend="gsf-off-t">gsf_off_t</link>           gsf_input_size                      (<link linkend="GsfInput">GsfInput</link> *input);</programlisting>
<para>
Looks up and caches the number of bytes in the input</para>
<para>

</para><variablelist role="params">
<varlistentry><term><parameter>input</parameter>&nbsp;:</term>
<listitem><simpara> The input
</simpara></listitem></varlistentry>
<varlistentry><term><emphasis>Returns</emphasis>&nbsp;:</term><listitem><simpara>  the size or -1 on error
</simpara></listitem></varlistentry>
</variablelist></refsect2>
<refsect2 id="gsf-input-eof" role="function">
<title>gsf_input_eof ()</title>
<indexterm zone="gsf-input-eof"><primary>gsf_input_eof</primary></indexterm><programlisting><link linkend="gboolean">gboolean</link>            gsf_input_eof                       (<link linkend="GsfInput">GsfInput</link> *input);</programlisting>
<para>
Are we at the end of the file ?</para>
<para>

</para><variablelist role="params">
<varlistentry><term><parameter>input</parameter>&nbsp;:</term>
<listitem><simpara> the input
</simpara></listitem></varlistentry>
<varlistentry><term><emphasis>Returns</emphasis>&nbsp;:</term><listitem><simpara> TRUE if the input is at the eof.
</simpara></listitem></varlistentry>
</variablelist></refsect2>
<refsect2 id="gsf-input-remaining" role="function">
<title>gsf_input_remaining ()</title>
<indexterm zone="gsf-input-remaining"><primary>gsf_input_remaining</primary></indexterm><programlisting><link linkend="gsf-off-t">gsf_off_t</link>           gsf_input_remaining                 (<link linkend="GsfInput">GsfInput</link> *input);</programlisting>
<para>
</para>
<para>

</para><variablelist role="params">
<varlistentry><term><parameter>input</parameter>&nbsp;:</term>
<listitem><simpara> the input stream
</simpara></listitem></varlistentry>
<varlistentry><term><emphasis>Returns</emphasis>&nbsp;:</term><listitem><simpara> the number of bytes left in the file.
</simpara></listitem></varlistentry>
</variablelist></refsect2>
<refsect2 id="gsf-input-error-id" role="function">
<title>gsf_input_error_id ()</title>
<indexterm zone="gsf-input-error-id"><primary>gsf_input_error_id</primary></indexterm><programlisting><link linkend="GQuark">GQuark</link>              gsf_input_error_id                  (void);</programlisting>
<para>
</para>
<para>

</para><variablelist role="params">
<varlistentry><term><emphasis>Returns</emphasis>&nbsp;:</term><listitem><simpara> A utility quark to flag a GError as being an input problem.
</simpara></listitem></varlistentry>
</variablelist></refsect2>
<refsect2 id="gsf-input-sibling" role="function">
<title>gsf_input_sibling ()</title>
<indexterm zone="gsf-input-sibling"><primary>gsf_input_sibling</primary></indexterm><programlisting><link linkend="GsfInput">GsfInput</link>*           gsf_input_sibling                   (<link linkend="GsfInput">GsfInput</link> const *input,
                                                         <link linkend="char">char</link> const *name,
                                                         <link linkend="GError">GError</link> **err);</programlisting>
<para>

</para><variablelist role="params">
<varlistentry><term><parameter>input</parameter>&nbsp;:</term>
<listitem><simpara>
</simpara></listitem></varlistentry>
<varlistentry><term><parameter>name</parameter>&nbsp;:</term>
<listitem><simpara>
</simpara></listitem></varlistentry>
<varlistentry><term><parameter>err</parameter>&nbsp;:</term>
<listitem><simpara>
</simpara></listitem></varlistentry>
<varlistentry><term><emphasis>Returns</emphasis>&nbsp;:</term><listitem><simpara>


</simpara></listitem></varlistentry>
</variablelist></refsect2>
<refsect2 id="gsf-input-error" role="function">
<title>gsf_input_error ()</title>
<indexterm zone="gsf-input-error"><primary>gsf_input_error</primary></indexterm><programlisting><link linkend="GQuark">GQuark</link>              gsf_input_error                     (void);</programlisting>
<para>
Deprecated as of GSF 1.12.0; use <link linkend="gsf-input-error-id"><function>gsf_input_error_id()</function></link> instead.</para>
<para>

</para><variablelist role="params">
<varlistentry><term><emphasis>Returns</emphasis>&nbsp;:</term><listitem><simpara> A utility quark to flag a GError as being an input problem.
</simpara></listitem></varlistentry>
</variablelist></refsect2>
<refsect2 id="gsf-input-name" role="function">
<title>gsf_input_name ()</title>
<indexterm zone="gsf-input-name"><primary>gsf_input_name</primary></indexterm><programlisting><link linkend="char">char</link>const   *       gsf_input_name                      (<link linkend="GsfInput">GsfInput</link> *input);</programlisting>
<para>
The name of the input stream.</para>
<para>

</para><variablelist role="params">
<varlistentry><term><parameter>input</parameter>&nbsp;:</term>
<listitem><simpara> the input stream
</simpara></listitem></varlistentry>
<varlistentry><term><emphasis>Returns</emphasis>&nbsp;:</term><listitem><simpara> <parameter>input</parameter>'s name in utf8 form, or <link linkend="NULL:CAPS"><literal>NULL</literal></link> if it has no name.
</simpara></listitem></varlistentry>
</variablelist></refsect2>
<refsect2 id="gsf-input-set-name-from-filename" role="function">
<title>gsf_input_set_name_from_filename ()</title>
<indexterm zone="gsf-input-set-name-from-filename"><primary>gsf_input_set_name_from_filename</primary></indexterm><programlisting><link linkend="gboolean">gboolean</link>            gsf_input_set_name_from_filename    (<link linkend="GsfInput">GsfInput</link> *input,
                                                         <link linkend="char">char</link> const *filename);</programlisting>
<para>
protected.</para>
<para>

</para><variablelist role="params">
<varlistentry><term><parameter>input</parameter>&nbsp;:</term>
<listitem><simpara> the input stream
</simpara></listitem></varlistentry>
<varlistentry><term><parameter>filename</parameter>&nbsp;:</term>
<listitem><simpara> the (fs-sys encoded) filename
</simpara></listitem></varlistentry>
<varlistentry><term><emphasis>Returns</emphasis>&nbsp;:</term><listitem><simpara> TRUE if the assignment was ok.
</simpara></listitem></varlistentry>
</variablelist></refsect2>
<refsect2 id="GsfInputProxy-struct" role="struct">
<title>GsfInputProxy</title>
<indexterm zone="GsfInputProxy-struct"><primary>GsfInputProxy</primary></indexterm><programlisting>typedef struct _GsfInputProxy GsfInputProxy;</programlisting>
<para>

</para></refsect2>
<refsect2 id="gsf-input-proxy-new" role="function">
<title>gsf_input_proxy_new ()</title>
<indexterm zone="gsf-input-proxy-new"><primary>gsf_input_proxy_new</primary></indexterm><programlisting><link linkend="GsfInput">GsfInput</link>*           gsf_input_proxy_new                 (<link linkend="GsfInput">GsfInput</link> *source);</programlisting>
<para>
This creates a new proxy to the entire, given input source.  See
gsf_input_proxy_new_section for details.</para>
<para>

</para><variablelist role="params">
<varlistentry><term><parameter>source</parameter>&nbsp;:</term>
<listitem><simpara> The underlying data source.
</simpara></listitem></varlistentry>
<varlistentry><term><emphasis>Returns</emphasis>&nbsp;:</term><listitem><simpara> a new input object.
</simpara></listitem></varlistentry>
</variablelist></refsect2>
<refsect2 id="gsf-input-proxy-new-section" role="function">
<title>gsf_input_proxy_new_section ()</title>
<indexterm zone="gsf-input-proxy-new-section"><primary>gsf_input_proxy_new_section</primary></indexterm><programlisting><link linkend="GsfInput">GsfInput</link>*           gsf_input_proxy_new_section         (<link linkend="GsfInput">GsfInput</link> *source,
                                                         <link linkend="gsf-off-t">gsf_off_t</link> offset,
                                                         <link linkend="gsf-off-t">gsf_off_t</link> size);</programlisting>
<para>
This creates a new proxy to a section of the given source.  The new
object will have its own current position, but any operation on it
can change the source's position.
</para>
<para>
If a proxy to a proxy is created, the intermediate proxy is short-
circuited.
</para>
<para>
This function will ref the source.</para>
<para>

</para><variablelist role="params">
<varlistentry><term><parameter>source</parameter>&nbsp;:</term>
<listitem><simpara> The underlying data source.
</simpara></listitem></varlistentry>
<varlistentry><term><parameter>offset</parameter>&nbsp;:</term>
<listitem><simpara> Offset into source for start of section.
</simpara></listitem></varlistentry>
<varlistentry><term><parameter>size</parameter>&nbsp;:</term>
<listitem><simpara> Length of section.
</simpara></listitem></varlistentry>
<varlistentry><term><emphasis>Returns</emphasis>&nbsp;:</term><listitem><simpara> a new input object.
</simpara></listitem></varlistentry>
</variablelist></refsect2>
<refsect2 id="gsf-input-copy" role="function">
<title>gsf_input_copy ()</title>
<indexterm zone="gsf-input-copy"><primary>gsf_input_copy</primary></indexterm><programlisting><link linkend="gboolean">gboolean</link>            gsf_input_copy                      (<link linkend="GsfInput">GsfInput</link> *input,
                                                         <link linkend="GsfOutput">GsfOutput</link> *output);</programlisting>
<para>
Copy the contents from <parameter>input</parameter> to <parameter>output</parameter> from their respective
current positions. So if you want to be sure to copy *everything*,
make sure to call gsf_input_seek (input, 0, G_SEEK_SET) and
gsf_output_seek (output, 0, G_SEEK_SET) first, if applicable.</para>
<para>

</para><variablelist role="params">
<varlistentry><term><parameter>input</parameter>&nbsp;:</term>
<listitem><simpara> a non-null <link linkend="GsfInput"><type>GsfInput</type></link>
</simpara></listitem></varlistentry>
<varlistentry><term><parameter>output</parameter>&nbsp;:</term>
<listitem><simpara> a non-null <link linkend="GsfOutput"><type>GsfOutput</type></link>
</simpara></listitem></varlistentry>
<varlistentry><term><emphasis>Returns</emphasis>&nbsp;:</term><listitem><simpara> TRUE on Success
</simpara></listitem></varlistentry>
</variablelist></refsect2>
<refsect2 id="gsf-input-uncompress" role="function">
<title>gsf_input_uncompress ()</title>
<indexterm zone="gsf-input-uncompress"><primary>gsf_input_uncompress</primary></indexterm><programlisting><link linkend="GsfInput">GsfInput</link>*           gsf_input_uncompress                (<link linkend="GsfInput">GsfInput</link> *src);</programlisting>
<para>
This functions takes ownership of the incoming reference and yields a
new one as its output.</para>
<para>

</para><variablelist role="params">
<varlistentry><term><parameter>src</parameter>&nbsp;:</term>
<listitem><simpara> stream to be uncompressed.
</simpara></listitem></varlistentry>
<varlistentry><term><emphasis>Returns</emphasis>&nbsp;:</term><listitem><simpara> A stream equivalent to the source stream, but uncompressed if
the source was compressed.
</simpara></listitem></varlistentry>
</variablelist></refsect2>

</refsect1>
<refsect1 id="gsf-Input-from-unstructured-files.property-details" role="property_details">
<title role="property_details.title">Property Details</title>
<refsect2 id="GsfInput--eof"><title>The <literal>&quot;eof&quot;</literal> property</title>
<indexterm zone="GsfInput--eof"><primary>GsfInput:eof</primary></indexterm><programlisting>  &quot;eof&quot;                      <link linkend="gboolean">gboolean</link>              : Read</programlisting>
<para>End Of File.</para><para>Default value: FALSE</para>
</refsect2>
<refsect2 id="GsfInput--name"><title>The <literal>&quot;name&quot;</literal> property</title>
<indexterm zone="GsfInput--name"><primary>GsfInput:name</primary></indexterm><programlisting>  &quot;name&quot;                     <link linkend="gchar">gchar</link>*                : Read</programlisting>
<para>The Input's Name.</para><para>Default value: NULL</para>
</refsect2>
<refsect2 id="GsfInput--position"><title>The <literal>&quot;position&quot;</literal> property</title>
<indexterm zone="GsfInput--position"><primary>GsfInput:position</primary></indexterm><programlisting>  &quot;position&quot;                 <link linkend="gint64">gint64</link>                : Read</programlisting>
<para>The Output's Current Position.</para><para>Allowed values: &gt;= 0</para>
<para>Default value: 0</para>
</refsect2>
<refsect2 id="GsfInput--remaining"><title>The <literal>&quot;remaining&quot;</literal> property</title>
<indexterm zone="GsfInput--remaining"><primary>GsfInput:remaining</primary></indexterm><programlisting>  &quot;remaining&quot;                <link linkend="gint64">gint64</link>                : Read</programlisting>
<para>Amount of Data Remaining.</para><para>Allowed values: &gt;= 0</para>
<para>Default value: 0</para>
</refsect2>
<refsect2 id="GsfInput--size"><title>The <literal>&quot;size&quot;</literal> property</title>
<indexterm zone="GsfInput--size"><primary>GsfInput:size</primary></indexterm><programlisting>  &quot;size&quot;                     <link linkend="gint64">gint64</link>                : Read</programlisting>
<para>The Input's Size.</para><para>Allowed values: &gt;= 0</para>
<para>Default value: 0</para>
</refsect2>

</refsect1>




</refentry>
